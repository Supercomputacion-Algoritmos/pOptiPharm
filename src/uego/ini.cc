#include "uego/uego.h"
#include "uego/uegoconf.h"
#include <stdlib.h>
#include <string.h>
////////////////////////////////////////////////////////////
// $Id: ini.cc,v 2.6 1998/04/01 21:05:42 jelasity Exp $
// ini.cc
// contains definitions of class Ini
////////////////////////////////////////////////////////////
// modification history:
//	Jelasity 98 01 23 bug fix in Ini(FILE*)
//	jelasity 98 01 24 double out format
////////////////////////////////////////////////////////////

// ------------------------------------------------------------------------

Ini::Ini(FILE *stream) {
  // we assume here that the ini file is correct, so don't do value
  // checks and that stuff. it should be generated by setup afterall...

  char *buff;

  FailFlag = 1 == 0; // it is ok here

  prototype = NULL;              // SetPrototype allocates memory
  param = r = lowb = upb = NULL; // GetVector allocates
  evals = newspecevals = NULL;   //		memory

  if (!ToBuffer(stream, &buff)) {
    FailFlag = 1 == 1;
    return;
  }

  // --- random numbers -------------------------------------------
  // seed = (unsigned long) GetValue( buff, SEED_T );
  seed = time(NULL);
  // --- objective function ---------------------------------------
  type = (long)GetValue(buff, TYPE_T);
  dimension = (long)GetValue(buff, DIM_T);
  if (Fail()) {
    delete[] buff;
    return;
  };

  fnum = (long)GetValue(buff, FNUM_T);
  if (Fail()) {
    fnum = 0;
    FailFlag = 1 == 0;
  };

  // --- uego parameters -------------------------------------------
  maxevals = (unsigned long)GetValue(buff, MAXEV_T);
  maxspecnum = (long)GetValue(buff, MAXSPEC_T);
  threshold = GetValue(buff, THR_T);
  levels = (long)GetValue(buff, LEVELS_T);
  last_r = GetValue(buff, LAST_R_T);
  if (Fail()) {
    delete[] buff;
    return;
  };

  // --- loading vectors ---------------------------------------------
  /* Removing paramnum
   * paramnum = (long) GetValue(buff, PARNUM_T);
  if (Fail()) {
          paramnum = 0;
          FailFlag = 1 == 0;
  } else
          FailFlag = !GetVector(buff, PAR_T, &param, NULL, paramnum);

*/

  if (!Fail() && BOUND_NEEDED(type)) {
    FailFlag = !GetVector(buff, LOWB_T, &lowb, NULL, dimension) ||
               !GetVector(buff, UPB_T, &upb, NULL, dimension);
  };

  // -- radius calculation level -------------------------------------
  double sqrsum = 0.0;
  r = new double[levels];

  for (long i = 0; i < dimension; ++i) {
    sqrsum += (lowb[i] - upb[i]) * (lowb[i] - upb[i]);
  };

  r[0] = sqrt(sqrsum);

  // --- calculate exponential factor for radii -------------
  double beta = pow((last_r / r[0]), 1.0 / (levels - 1));

  // --- calculate radii ------------------------------------
  for (long i = 1; i < levels; ++i)
    r[i] = r[i - 1] * beta;

  // -- evals for creation -------------------------------------------
  evals = new unsigned long[levels];
  evals[0] = 0;
  newspecevals = new unsigned long[levels - 1];

  for (int i = 1; i < levels; ++i) {
    // newspecevals[i-1] = 100 * maxspecnum;
    newspecevals[i - 1] = 3 * maxspecnum;
  }
  int evals1;
  // -- evals for optimization -------------------------------------------
  evals1 = maxevals;
  for (int i = 1; i < levels; ++i)
    evals1 -= newspecevals[i - 1];
  if (evals1 < 0) {
    message((char *)"All evaluations (N) too small, parameters not set.",
            MSG_ERROR);
    FailFlag = 1 == 1;
    return;
  };

  //---initial threshold
  threshold = 1.0;
  //---initial number of function evaluation for optimization process
  for (int i = 1; i < levels; ++i) {
    evals[i] = (unsigned long)(maxspecnum * r[0] * threshold / V(r[i]));
  }

  int evals2;
  //---threashold calculation
  evals2 = 0;
  for (int i = 0; i < levels; ++i) {
    evals2 += evals[i];
  }

  threshold = evals1 / (double)evals2;

  //---Calculate the number of function evaluation for optimization process
  for (int i = 1; i < levels; ++i) {
    evals[i] = (unsigned long)(maxspecnum * r[0] * threshold / V(r[i]));
  }

  delete[] buff;

  if (!Fail())
    SetPrototype();

  if (FailFlag)
    message("Failed loading ini file.", MSG_ERROR);

  this->molQuery = NULL;
  this->molVariable = NULL;

  this->pathOutputFiles = "./";
  this->sameVanDerWaalsRadius = true;
  this->considerHydrogens = false;
  this->saveSolutionMol2Files = false;
  this->lowLimit = 0;
};

// ------------------------------------------------------------------------

double Ini::V(double r) {
#define SPEED_CONSTANTS 14
  //  Using that binom(x,(x-1)/2)==.5*binom(x+1,(x+1)/2) and
  //  binom(2n,n) is approx. 2**(2n)/sqrt(pi*n)

  double V[SPEED_CONSTANTS] = {// for r==1.0
                               0.0,
                               .25,
                               M_2_PI / 3.0,
                               3.0 / 16.0,
                               4 * M_2_PI / 15.0,
                               10.0 / 64.0,
                               8 * M_2_PI / 35.0,
                               35.0 / 256.0,
                               64 * M_2_PI / 315.0,
                               63.0 / 512.0,
                               128 * M_2_PI / 693.0,
                               231.0 / 2048.0,
                               512 * M_2_PI / 3003.0,
                               858.0 / 8192.0};

  if (dimension < SPEED_CONSTANTS)
    return V[dimension] * r;
  else
    return r / sqrt(M_PI * (2 * (dimension + 1)));

#undef SPEED_CONSTANTS
};

Ini::Ini(FILE *stream, int argc, char **argv) {
  // we assume here that the ini file is correct, so don't do value
  // checks and that stuff. it should be generated by setup afterall...

  char *buff;

  FailFlag = 1 == 0; // it is ok here

  prototype = NULL;              // SetPrototype allocates memory
  param = r = lowb = upb = NULL; // GetVector allocates
  evals = newspecevals = NULL;   //		memory

  if (!ToBuffer(stream, &buff)) {
    FailFlag = 1 == 1;
    return;
  }

  // --- random numbers -------------------------------------------
  // seed = (unsigned long) GetValue( buff, SEED_T );
  seed = time(NULL);
  // --- objective function ---------------------------------------
  type = (long)GetValue(buff, TYPE_T);
  dimension = (long)GetValue(buff, DIM_T);
  if (Fail()) {
    delete buff;
    return;
  };

  fnum = (long)GetValue(buff, FNUM_T);
  if (Fail()) {
    fnum = 0;
    FailFlag = 1 == 0;
  };

  // --- uego parameters -------------------------------------------
  maxevals = (unsigned long)GetValue(buff, MAXEV_T);
  maxspecnum = (long)GetValue(buff, MAXSPEC_T);
  threshold = GetValue(buff, THR_T);
  levels = (long)GetValue(buff, LEVELS_T);
  last_r = GetValue(buff, LAST_R_T);

  for (long i = 0; i < argc; i++) {
    string arg(argv[i]);
    if (arg == "-N") {
      maxevals = strtoul(argv[i + 1], NULL, 0);

    } else if (arg == "-M") {
      maxspecnum = strtoul(argv[i + 1], NULL, 0);

    } else if (arg == "-L") {
      levels = strtoul(argv[i + 1], NULL, 0);

    } else if (arg == "-R") {
      last_r = atof(argv[i + 1]);
    }
  }

  if (Fail()) {
    delete buff;
    return;
  };

  // --- loading vectors ---------------------------------------------

  if (!Fail() && BOUND_NEEDED(type)) {
    FailFlag = !GetVector(buff, (char *)LOWB_T, &lowb, NULL, dimension) ||
               !GetVector(buff, (char *)UPB_T, &upb, NULL, dimension);
  };

  // -- radius calculation level -------------------------------------
  double sqrsum = 0.0;
  r = new double[levels];

  for (long i = 0; i < dimension; ++i) {
    sqrsum += (lowb[i] - upb[i]) * (lowb[i] - upb[i]);
  };

  r[0] = sqrt(sqrsum);

  // --- calculate exponential factor for radii -------------
  double beta = pow((last_r / r[0]), 1.0 / (levels - 1));

  // --- calculate radii ------------------------------------
  for (long i = 1; i < levels; ++i)
    r[i] = r[i - 1] * beta;

  // -- evals for creation -------------------------------------------
  evals = new unsigned long[levels];
  newspecevals = new unsigned long[levels - 1];

  for (int i = 1; i < levels; ++i)
    // newspecevals[i-1] = 100 * maxspecnum;
    newspecevals[i - 1] = 3 * maxspecnum;
  int evals1;
  // -- evals for optimization -------------------------------------------
  evals1 = maxevals;
  for (int i = 1; i < levels; ++i)
    evals1 -= newspecevals[i - 1];
  if (evals1 < 0) {
    message((char *)"All evaluations (N) too small, parameters not set.",
            MSG_ERROR);
    FailFlag = 1 == 1;
    return;
  };

  //---initial threshold
  threshold = 1.0;
  //---initial number of function evaluation for optimization process
  for (int i = 1; i < levels; ++i)
    evals[i] = (unsigned long)(maxspecnum * r[0] * threshold / V(r[i]));
  int evals2;
  //---threashold calculation
  evals2 = 0;
  for (int i = 0; i < levels; ++i)
    evals2 += evals[i];
  threshold = evals1 / (double)evals2;

  //---Calculate the number of function evaluation for optimization process
  for (int i = 1; i < levels; ++i) {
    evals[i] = (unsigned long)(maxspecnum * r[0] * threshold / V(r[i]));
  }

  delete buff;

  if (!Fail())
    SetPrototype();

  if (FailFlag)
    message("Failed loading ini file.", MSG_ERROR);

  molQuery = new Molecule();
  molVariable = new Molecule();

  this->pathOutputFiles = "./";
  this->sameVanDerWaalsRadius = true;
  this->considerHydrogens = false;
  this->lowLimit = 0;
};

// ------------------------------------------------------------------------

Ini::Ini() {

  FailFlag = 1 == 1;

  prototype = NULL; // SetPrototype allocates memory
  param = r = lowb = upb = NULL;
  evals = newspecevals = NULL;

  // --- random numbers
  // seed = 123456789;
  seed = time(NULL);

  // --- objective function
  type = NDIMREAL_TYPE;
  fnum = 6;
  dimension = 1;
  paramnum = 0;
  param = NULL;
  lowb = new double[1];
  upb = new double[1];
  if (lowb == NULL || upb == NULL) {
    message("No memory in ini constructor.", MSG_ERROR);
    return;
  };
  lowb[0] = 0.0;
  upb[0] = 10.0;

  // --- uego parameters
  maxevals = 20000;
  maxspecnum = 50;
  threshold = 1.0;
  levels = 3;
  newspecevals = new unsigned long[levels - 1];
  r = new double[levels];
  evals = new unsigned long[levels];
  if (evals == NULL || newspecevals == NULL || r == NULL) {
    message("No memory in ini constructor.", MSG_ERROR);
    return;
  };
  newspecevals[0] = 300;
  newspecevals[1] = 300;
  r[0] = 10;
  r[1] = 1.5;
  r[2] = .2;
  evals[0] = 0;
  evals[1] = 657;
  evals[2] = 18743;

  SetPrototype();
  // FailFlag is set properly!
};

// ------------------------------------------------------------------------

Ini::~Ini() {

  if (param != NULL)
    delete param;
  if (r != NULL)
    delete[] r;
  if (lowb != NULL)
    delete[] lowb;
  if (upb != NULL)
    delete[] upb;
  if (evals != NULL)
    delete[] evals;
  if (newspecevals != NULL)
    delete[] newspecevals;
  if (prototype != NULL)
    delete prototype;
  if (molQuery != NULL)
    delete molQuery;
};

// ------------------------------------------------------------------------

void Ini::SetPrototype() {

  FailFlag = 1 == 1;

  if (prototype != NULL)
    delete prototype;
  switch (type) {
  case NDIMREAL_TYPE:
    prototype = new NDimMolElement(dimension);
    break;
  };

  if (prototype->Fail() || prototype == NULL) {
    message("Error setting prototype.", MSG_ERROR);
    return;
  };

  FailFlag = 1 == 0;
};

// ------------------------------------------------------------------------

void Ini::Save(FILE *stream) {

  long i;

  FailFlag =
      fprintf(stream, INI_OUT_HEADER) == EOF ||

      // --- random numbers -------------------------------------------
      fprintf(stream, "\n[Random numbers]\n\n") == EOF ||
      fprintf(stream, "\t%s\t%lu\n", SEED_T, seed) == EOF ||

      // --- objective function ---------------------------------------
      fprintf(stream, "\n[Objective function]\n\n") == EOF ||
      fprintf(stream, "\t%s\t%ld\n\t%s\t\t%ld\n\t%s\t%ld\n", TYPE_T, (long)type,
              FNUM_T, (long)fnum, DIM_T, (long)dimension) == EOF;

  // --- saving lower and upper bounds if any
  FailFlag = FailFlag || !SaveVector(stream, LOWB_T, lowb, NULL, dimension) ||
             !SaveVector(stream, UPB_T, upb, NULL, dimension);

  // --- saving constant parameters if any
  /*
   *Removing paramnum
   *
   if (!FailFlag && paramnum != 0) {
          FailFlag = fprintf(stream, "\t%s\t%ld\n",
          PARNUM_T, (long) paramnum) == EOF
                          || !SaveVector(stream, PAR_T, param, NULL, paramnum);
  };
*/
  // --- uego parameters ------------------------------------------
  FailFlag =
      FailFlag || fprintf(stream, "\n[UEGO parameters]\n\n") == EOF ||
      fprintf(stream,
              "\t%s\t%lu\n\t%s\t%ld\n\t%s\t%lg\n\t%s\t\t\t%ld\n\t%s\t%le\n",
              MAXEV_T, maxevals, MAXSPEC_T, (long)maxspecnum, THR_T, threshold,
              LEVELS_T, (long)levels, LAST_R_T, last_r) == EOF;

  if (FailFlag)
    message("Failed writing ini file.", MSG_ERROR);
};

// ------------------------------------------------------------------------

char Ini::SaveVector(FILE *stream, char *name, double *d, unsigned long *ul,
                     long length) {
  // static member
  // purpose: saves 'name', and after name saves 'length'
  //	doubles if d != NULL otherwise 'length' unsigned longs.
  //	the values are saved from 'd' or 'ul' accordingly.
  //      the values are separated by whitespace (including new lines) only
  // returns true if success, false if not

  char FailFlag, IsDouble = d != NULL;
  long i;

  if (length == 0 || (d == NULL && ul == NULL))
    return 1 == 1;
  FailFlag = fprintf(stream, "\t%s", name) == EOF;
  for (i = 0; !FailFlag && i < length; ++i) {
    if (i % 6 == 0)
      FailFlag = fprintf(stream, "\n\t\t") == EOF;
    if (!FailFlag && IsDouble)
      if (fabs(d[i]) < 1.0)
        FailFlag = fprintf(stream, "%le ", d[i]) == EOF;
      else
        FailFlag = fprintf(stream, "%lf ", d[i]) == EOF;
    else
      FailFlag = fprintf(stream, "%lu ", ul[i]) == EOF;
  };
  FailFlag = FailFlag || fprintf(stream, "\n") == EOF;
  return !FailFlag;
};

// ------------------------------------------------------------------------

char Ini::ToBuffer(FILE *stream, char **buff) {
  // static member
  // purpose:
  //	load 'stream' to '*buff'. Also performs memory allocation according
  //	to size of input file. performs no formatting
  // returns true if success, false if not

  long i, length = 0;

  // --- read test
  if (fseek(stream, 0, SEEK_SET) != 0) {
    message("Cannot read ini file.", MSG_ERROR);
    return 1 == 0;
  };

  // --- allocate memory
  for (fgetc(stream); !feof(stream); fgetc(stream))
    ++length;
  if (length == 0) {
    buff = NULL;
    message("Zero length ini file.", MSG_ERROR);
    return 1 == 0;
  };
  if ((*buff = new char[length]) == NULL) {
    message("No memory for loading ini file.", MSG_ERROR);
    return 1 == 0;
  };

  // --- read ini file
  // (fgetc must be used because of DOS)
  rewind(stream);
  for (i = 0; !feof(stream) && i < length; ++i)
    (*buff)[i] = (char)fgetc(stream);

  return 1 == 1;
};

// ------------------------------------------------------------------------

char Ini::GetVector(char *buff, char *name, double **d, unsigned long **ul,
                    long length) {
  // static member
  // purpose: finds 'name' in buff, and after name tries to read 'length'
  //	doubles if d != NULL otherwise 'length' unsigned longs.
  //	the values are saved to *d or *ul accordingly.
  //      the values must be separated by whitespace only
  //	performs memory allocation too.
  // returns true if success, false if not

  char FailFlag, IsDouble = d != NULL, *pos, msg[100],
                 white[15] = " \n\v\b\r\f\t";
  long i;
  double db;

  if (length == 0 || (d == NULL && ul == NULL))
    return 1 == 1;
  FailFlag = 1 == 1;

  // --- find token in ini file -------------------------------------
  if ((pos = strstr(buff, name)) == NULL) {
    sprintf(msg, "Could not find '%s' in ini file", name);
    message(msg, MSG_INFORMATION);
    return !FailFlag;
  };
  pos += strlen(name); // position after the token

  // --- allocate memory --------------------------------------------
  if (IsDouble)
    (*d) = new double[length];
  else
    (*ul) = new unsigned long[length];
  if (IsDouble && *d == NULL || !IsDouble && *ul == NULL) {
    message("No memory while loading ini file.", MSG_ERROR);
    return !FailFlag;
  };

  // --- read data --------------------------------------------------
  FailFlag = 1 == 0;
  for (i = 0; i < length && !FailFlag; ++i) {

    pos += strspn(pos, white); // skip leading whitespace
    FailFlag = FailFlag || sscanf(pos, "%lf ", &db) != 1;

    if (IsDouble)
      (*d)[i] = db;
    else
      (*ul)[i] = (unsigned long)db;
    pos = strpbrk(pos, white); // skip number just read

    if (pos == NULL)
      FailFlag = 1 == 1;
  };

  if (FailFlag) {

    sprintf(msg, "Failed loading '%s' from ini file", name);

    message(msg, MSG_ERROR);
  };

  return !FailFlag;
};

// ------------------------------------------------------------------------

double Ini::GetValue(char *buff, char *name) {
  // could be static but it's more natural to use
  // FailFlag here than something else to inidicate error

  double *d, result;

  d = NULL;
  FailFlag = FailFlag || !GetVector(buff, name, &d, NULL, 1);

  if (!Fail())
    result = d[0];
  else
    result = 0.0;
  if (d != NULL)
    delete[] d;

  return result;
};

void Ini::updateVectorIni() {
  this->setLastR(this->R(this->Levels()));
  // -- radius calculation level -------------------------------------
  double sqrsum = 0.0;
  double *r = new double[this->getLevels()];

  for (long i = 0; i < this->Dimension(); ++i) {
    sqrsum += (this->Lowb(i) - this->Upb(i)) * (this->Lowb(i) - this->Upb(i));
  };

  r[0] = sqrt(sqrsum); // 6.28318530718;

  // --- calculate exponential factor for radii -------------
  double beta = pow((this->getLastR() / r[0]), 1.0 / (this->getLevels() - 1));

  // --- calculate radii ------------------------------------
  for (long i = 1; i < this->getLevels(); ++i) {
    r[i] = r[i - 1] * beta;
  }
  // -- evals for creation -------------------------------------------
  evals = new unsigned long[this->getLevels()];
  evals[0] = 0;
  newspecevals = new unsigned long[this->getLevels() - 1];

  for (int i = 1; i < this->getLevels(); ++i)
    // newspecevals[i-1] = 100 * maxspecnum;
    newspecevals[i - 1] = 3 * this->MaxSpecNumber();
  int evals1;
  // -- evals for optimization -------------------------------------------
  evals1 = this->MaxEvals();
  for (int i = 1; i < this->Levels(); ++i)
    evals1 -= newspecevals[i - 1];
  if (evals1 < 0) {
    message((char *)"All evaluations (N) too small, parameters not set.",
            MSG_ERROR);
    this->setFailFlag(1 == 1);
    return;
  };

  //---initial threshold
  double threshold = 1.0;
  //---initial number of function evaluation for optimization process
  for (int i = 1; i < this->Levels(); ++i) {
    // cout << "i: "<<i << "\n";
    evals[i] =
        (unsigned long)(this->MaxSpecNumber() * r[0] * threshold / V(r[i]));
    // cout << "Evals: "<< evals[i] << " MaxSpecNumber "<< this->MaxSpecNumber()
    // << ", r[0]: " << r[0] << ", V(r[i]): " <<V(r[i]) << "\n";
  }

  unsigned long evals2;
  //---threashold calculation
  evals2 = 0;
  for (int i = 0; i < this->Levels(); ++i) {
    evals2 += evals[i];
  }

  threshold = evals1 / (double)evals2;

  //---Calculate the number of function evaluation for optimization process
  for (int i = 1; i < this->Levels(); ++i) {
    evals[i] = (unsigned long)(this->MaxSpecNumber() * r[0] * fabs(threshold) /
                               V(r[i]));
  }

  this->setEvals(evals);
  this->setr(r);
  this->setNewspecevals(newspecevals);
  this->setThreshold(threshold);
  // cout << "En el ini: "<<threshold << "\n";
}
